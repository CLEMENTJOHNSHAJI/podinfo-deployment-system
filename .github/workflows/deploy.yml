name: Deploy to Dual Targets

on:
  workflow_run:
    workflows: ["Build, Sign, and SBOM"]
    types: [completed]
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy (commit SHA)'
        required: false
        type: string

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-west-2.amazonaws.com
  IMAGE_TAG: ${{ github.event.workflow_run.head_sha || inputs.image_tag || github.sha }}
  ENABLE_CODEDEPLOY: ${{ secrets.ENABLE_CODEDEPLOY || 'false' }}

jobs:
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || (github.event.workflow_run.conclusion == 'success' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main'))
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get image digests
        id: get-digests
        run: |
          IMAGE_TAG="${{ github.event.workflow_run.head_sha }}"
          
          # Get EC2 image digest
          EC2_DIGEST=$(aws ecr describe-images \
            --repository-name podinfo-podinfo \
            --image-ids imageTag=$IMAGE_TAG \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          echo "ec2_digest=$EC2_DIGEST" >> $GITHUB_OUTPUT
          echo "EC2 Image Digest: $EC2_DIGEST"
          
          # Get Lambda image digest
          LAMBDA_DIGEST=$(aws ecr describe-images \
            --repository-name podinfo-podinfo-lambda \
            --image-ids imageTag=$IMAGE_TAG \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          echo "lambda_digest=$LAMBDA_DIGEST" >> $GITHUB_OUTPUT
          echo "Lambda Image Digest: $LAMBDA_DIGEST"
      
      - name: Deploy Lambda function
        run: |
          IMAGE_TAG="${{ env.IMAGE_TAG }}"
          
          if aws lambda get-function --function-name podinfo-lambda >/dev/null 2>&1; then
            aws lambda update-function-code \
              --function-name podinfo-lambda \
              --image-uri ${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG
            aws lambda wait function-updated --function-name podinfo-lambda
          else
            aws lambda create-function \
              --function-name podinfo-lambda \
              --package-type Image \
              --code ImageUri=${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/podinfo-lambda-execution-role \
              --timeout 30 \
              --memory-size 512 \
              --environment Variables='{ENVIRONMENT=dev,LOG_LEVEL=INFO}'
            aws lambda wait function-active --function-name podinfo-lambda
          fi
          
          aws lambda publish-version \
            --function-name podinfo-lambda \
            --description "Deployment $IMAGE_TAG"
      
      - name: Deploy Lambda with CodeDeploy
        if: env.ENABLE_CODEDEPLOY == 'true'
        run: |
          if aws codedeploy help >/dev/null 2>&1; then
            aws codedeploy create-deployment \
              --application-name podinfo-lambda-deploy \
              --deployment-group-name podinfo-lambda-group \
              --deployment-config-name CodeDeployDefault.LambdaCanary10Percent5Minutes \
              --description "Deploy ${{ env.IMAGE_TAG }} to Lambda"
          else
            echo "CodeDeploy not available, skipping blue/green deployment"
          fi
      
      - name: Deploy EC2 application
        run: |
          # Get the latest Auto Scaling Group instances
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --query 'AutoScalingGroups[?contains(AutoScalingGroupName, `podinfo`)].AutoScalingGroupName' --output text)
          
          # Create user data script
          cat > user_data.sh << 'EOF'
          #!/bin/bash
          # Update system
          yum update -y
          
          # Install Docker
          yum install -y docker
          systemctl start docker
          systemctl enable docker
          
          # Install CloudWatch agent
          yum install -y amazon-cloudwatch-agent
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          # Pull and run the new image
          docker pull ${{ secrets.ECR_REPOSITORY_EC2 }}:${{ steps.get-digests.outputs.ec2_digest }}
          docker stop podinfo || true
          docker rm podinfo || true
          docker run -d --name podinfo -p 8080:8080 ${{ secrets.ECR_REPOSITORY_EC2 }}:${{ steps.get-digests.outputs.ec2_digest }}
          
          # Start CloudWatch agent
          /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c ssm:AmazonCloudWatch-linux -s
          EOF
          
          # Auto-discover AMI and Security Group if secrets not set
          EC2_AMI_ID="${{ secrets.EC2_AMI_ID }}"
          EC2_SECURITY_GROUP_ID="${{ secrets.EC2_SECURITY_GROUP_ID }}"
          
          if [ -z "$EC2_AMI_ID" ]; then
            EC2_AMI_ID=$(aws ec2 describe-images --owners amazon --filters "Name=name,Values=al2023-ami-2023*x86_64" --query 'Images|sort_by(@,&CreationDate)|[-1].ImageId' --output text)
            echo "Auto-discovered AMI: $EC2_AMI_ID"
          fi
          
          if [ -z "$EC2_SECURITY_GROUP_ID" ]; then
            EC2_SECURITY_GROUP_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=podinfo-*" --query 'SecurityGroups[0].GroupId' --output text)
            echo "Auto-discovered SG: $EC2_SECURITY_GROUP_ID"
          fi
          
          USER_DATA_B64=$(base64 -w 0 user_data.sh)
          
          NEW_LAUNCH_TEMPLATE_ID=$(aws ec2 create-launch-template \
            --launch-template-name podinfo-github-actions-$(date +%s) \
            --launch-template-data "UserData=$USER_DATA_B64,ImageId=$EC2_AMI_ID,InstanceType=t3.micro,SecurityGroupIds=$EC2_SECURITY_GROUP_ID" \
            --query 'LaunchTemplate.LaunchTemplateId' --output text)
          
          # Update Auto Scaling Group to use new Launch Template
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name $ASG_NAME \
            --launch-template LaunchTemplateId=$NEW_LAUNCH_TEMPLATE_ID,Version='$Latest'
      
      - name: Deploy EC2 with CodeDeploy
        if: env.ENABLE_CODEDEPLOY == 'true'
        run: |
          if aws codedeploy help >/dev/null 2>&1; then
            aws codedeploy create-deployment \
              --application-name podinfo-ec2-deploy \
              --deployment-group-name podinfo-ec2-group \
              --deployment-config-name CodeDeployDefault.AllAtOnce \
              --description "Deploy ${{ env.IMAGE_TAG }} to EC2"
          else
            echo "CodeDeploy not available, skipping blue/green deployment"
          fi
      
      - name: Wait for deployments
        run: sleep 300
      
      - name: Run smoke tests
        run: |
          LAMBDA_URL=$(aws apigatewayv2 get-apis --query 'Items[?contains(Name, `podinfo`)].ApiEndpoint | [0]' --output text 2>/dev/null || echo "")
          if [ -n "$LAMBDA_URL" ] && [ "$LAMBDA_URL" != "None" ]; then
            curl -f -m 10 "$LAMBDA_URL/healthz" || echo "Lambda health check failed"
          fi
          
          ALB_DNS=$(aws elbv2 describe-load-balancers --query 'LoadBalancers[?contains(LoadBalancerName, `podinfo`)].DNSName | [0]' --output text 2>/dev/null || echo "")
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            curl -f -m 10 "http://$ALB_DNS/healthz" || echo "ALB health check failed"
          fi
      
      - name: Run synthetic tests
        run: ./scripts/smoke-tests.sh dev
      
      - name: Update deployment status
        run: echo "Deployment to dev completed - Image ${{ env.IMAGE_TAG }}"

  promote-to-prod:
    name: Promote to Production
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    if: success() && (github.event_name == 'workflow_dispatch' || (github.event.workflow_run.conclusion == 'success' && github.ref == 'refs/heads/main'))
    environment: production
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Verify image signature
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.2.0'
      
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Deploy Lambda function
        run: |
          IMAGE_TAG="${{ env.IMAGE_TAG }}"
          
          if aws lambda get-function --function-name podinfo-lambda >/dev/null 2>&1; then
            aws lambda update-function-code \
              --function-name podinfo-lambda \
              --image-uri ${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG
            aws lambda wait function-updated --function-name podinfo-lambda
          else
            aws lambda create-function \
              --function-name podinfo-lambda \
              --package-type Image \
              --code ImageUri=${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/podinfo-lambda-execution-role \
              --timeout 30 \
              --memory-size 512 \
              --environment Variables='{ENVIRONMENT=prod,LOG_LEVEL=INFO}'
            aws lambda wait function-active --function-name podinfo-lambda
          fi
          
          aws lambda publish-version \
            --function-name podinfo-lambda \
            --description "Production deployment $IMAGE_TAG"
      
      - name: Deploy Lambda with CodeDeploy
        if: env.ENABLE_CODEDEPLOY == 'true'
        run: |
          if aws codedeploy help >/dev/null 2>&1; then
            aws codedeploy create-deployment \
              --application-name podinfo-lambda-deploy \
              --deployment-group-name podinfo-lambda-group \
              --deployment-config-name CodeDeployDefault.LambdaCanary10Percent5Minutes \
              --description "Production deploy ${{ env.IMAGE_TAG }} to Lambda"
          else
            echo "CodeDeploy not available, skipping blue/green deployment"
          fi
      
      - name: Deploy EC2 application
        run: |
          # Get the latest Auto Scaling Group instances
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --query 'AutoScalingGroups[?contains(AutoScalingGroupName, `podinfo`)].AutoScalingGroupName' --output text)
          
          # Create user data script
          cat > user_data.sh << 'EOF'
          #!/bin/bash
          # Update system
          yum update -y
          
          # Install Docker
          yum install -y docker
          systemctl start docker
          systemctl enable docker
          
          # Install CloudWatch agent
          yum install -y amazon-cloudwatch-agent
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          # Pull and run the new image
          docker pull ${{ secrets.ECR_REPOSITORY_EC2 }}:${{ steps.get-digests.outputs.ec2_digest }}
          docker stop podinfo || true
          docker rm podinfo || true
          docker run -d --name podinfo -p 8080:8080 ${{ secrets.ECR_REPOSITORY_EC2 }}:${{ steps.get-digests.outputs.ec2_digest }}
          
          # Start CloudWatch agent
          /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c ssm:AmazonCloudWatch-linux -s
          EOF
          
          # Auto-discover AMI and Security Group if secrets not set
          EC2_AMI_ID="${{ secrets.EC2_AMI_ID }}"
          EC2_SECURITY_GROUP_ID="${{ secrets.EC2_SECURITY_GROUP_ID }}"
          
          if [ -z "$EC2_AMI_ID" ]; then
            EC2_AMI_ID=$(aws ec2 describe-images --owners amazon --filters "Name=name,Values=al2023-ami-2023*x86_64" --query 'Images|sort_by(@,&CreationDate)|[-1].ImageId' --output text)
            echo "Auto-discovered AMI: $EC2_AMI_ID"
          fi
          
          if [ -z "$EC2_SECURITY_GROUP_ID" ]; then
            EC2_SECURITY_GROUP_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=podinfo-*" --query 'SecurityGroups[0].GroupId' --output text)
            echo "Auto-discovered SG: $EC2_SECURITY_GROUP_ID"
          fi
          
          USER_DATA_B64=$(base64 -w 0 user_data.sh)
          
          NEW_LAUNCH_TEMPLATE_ID=$(aws ec2 create-launch-template \
            --launch-template-name podinfo-github-actions-$(date +%s) \
            --launch-template-data "UserData=$USER_DATA_B64,ImageId=$EC2_AMI_ID,InstanceType=t3.micro,SecurityGroupIds=$EC2_SECURITY_GROUP_ID" \
            --query 'LaunchTemplate.LaunchTemplateId' --output text)
          
          # Update Auto Scaling Group to use new Launch Template
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name $ASG_NAME \
            --launch-template LaunchTemplateId=$NEW_LAUNCH_TEMPLATE_ID,Version='$Latest'
      
      - name: Deploy EC2 with CodeDeploy
        if: env.ENABLE_CODEDEPLOY == 'true'
        run: |
          if aws codedeploy help >/dev/null 2>&1; then
            aws codedeploy create-deployment \
              --application-name podinfo-ec2-deploy \
              --deployment-group-name podinfo-ec2-group \
              --deployment-config-name CodeDeployDefault.AllAtOnce \
              --description "Production deploy ${{ env.IMAGE_TAG }} to EC2"
          else
            echo "CodeDeploy not available, skipping blue/green deployment"
          fi
      
      - name: Wait for deployments
        run: sleep 300
      
      - name: Run production smoke tests
        run: |
          set +e
          
          echo "Running production smoke tests..."
          
          # Test Lambda endpoint
          LAMBDA_URL=$(aws apigatewayv2 get-apis --query 'Items[?contains(Name, `podinfo`)].ApiEndpoint | [0]' --output text 2>/dev/null || echo "")
          if [ -z "$LAMBDA_URL" ] || [ "$LAMBDA_URL" == "None" ]; then
              echo "Lambda API Gateway not found - deployment may be in progress"
          else
              echo "Testing Lambda URL: $LAMBDA_URL"
              if curl -sf "$LAMBDA_URL/healthz" > /dev/null 2>&1; then
                  echo "Lambda health check passed"
              else
                  echo "Lambda health check failed"
              fi
          fi
          
          # Test ALB endpoint
          ALB_DNS=$(aws elbv2 describe-load-balancers --query 'LoadBalancers[?contains(LoadBalancerName, `podinfo`)].DNSName | [0]' --output text 2>/dev/null || echo "")
          if [ -z "$ALB_DNS" ] || [ "$ALB_DNS" == "None" ]; then
              echo "ALB not found - deployment may be in progress"
          else
              echo "Testing ALB DNS: $ALB_DNS"
              if curl -sf "http://$ALB_DNS/healthz" > /dev/null 2>&1; then
                  echo "ALB health check passed"
              else
                  echo "ALB health check failed"
              fi
          fi
          
          echo "Production smoke tests completed"
          exit 0
      
      - name: Update production status
        run: echo "Production deployment completed - Image ${{ env.IMAGE_TAG }}"

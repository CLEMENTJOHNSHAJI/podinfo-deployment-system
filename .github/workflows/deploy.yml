name: Deploy to Dual Targets

on:
  workflow_run:
    workflows: ["Build, Sign, and SBOM"]
    types: [completed]
    branches: [main, develop]

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-west-2.amazonaws.com
  IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}
  ENABLE_CODEDEPLOY: ${{ secrets.ENABLE_CODEDEPLOY || 'false' }}

jobs:
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    needs: []
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get image digests
        id: get-digests
        run: |
          # Get the actual image digests (not just the tag)
          # The build workflow tags images with commit SHA, we need the actual digest
          IMAGE_TAG="${{ github.event.workflow_run.head_sha }}"
          
          # Get EC2 image digest
          EC2_DIGEST=$(aws ecr describe-images \
            --repository-name podinfo-podinfo \
            --image-ids imageTag=$IMAGE_TAG \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          echo "ec2_digest=$EC2_DIGEST" >> $GITHUB_OUTPUT
          echo "EC2 Image Digest: $EC2_DIGEST"
          
          # Get Lambda image digest
          LAMBDA_DIGEST=$(aws ecr describe-images \
            --repository-name podinfo-podinfo-lambda \
            --image-ids imageTag=$IMAGE_TAG \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          echo "lambda_digest=$LAMBDA_DIGEST" >> $GITHUB_OUTPUT
          echo "Lambda Image Digest: $LAMBDA_DIGEST"
      
      - name: Deploy Lambda function
        run: |
          IMAGE_TAG="${{ github.event.workflow_run.head_sha }}"
          echo "Deploying Lambda function with image: ${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG"
          
          # Check if Lambda function exists
          if aws lambda get-function --function-name podinfo-lambda >/dev/null 2>&1; then
            echo "Lambda function exists, updating with container image..."
            aws lambda update-function-code \
              --function-name podinfo-lambda \
              --image-uri ${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG
            # Wait for update to complete
            echo "Waiting for Lambda function update to complete..."
            aws lambda wait function-updated --function-name podinfo-lambda
          else
            echo "Lambda function does not exist, creating with container image..."
            aws lambda create-function \
              --function-name podinfo-lambda \
              --package-type Image \
              --code ImageUri=${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/podinfo-lambda-execution-role \
              --timeout 30 \
              --memory-size 512 \
              --environment Variables='{ENVIRONMENT=dev,LOG_LEVEL=INFO}'
            # Wait for function to be ready
            echo "Waiting for Lambda function to be ready..."
            aws lambda wait function-active --function-name podinfo-lambda
          fi
          
          # Verify the deployment
          echo "Verifying Lambda function deployment..."
          aws lambda get-function --function-name podinfo-lambda --query 'Configuration.{State:State,LastUpdateStatus:LastUpdateStatus,CodeSize:CodeSize,ImageUri:Code.ImageUri}' --output table
        
          aws lambda publish-version \
            --function-name podinfo-lambda \
            --description "Deployment $IMAGE_TAG"
      
      - name: Deploy Lambda with CodeDeploy
        if: env.ENABLE_CODEDEPLOY == 'true'
        run: |
          # Check if CodeDeploy is available
          if aws codedeploy help > /dev/null 2>&1; then
            aws codedeploy create-deployment \
              --application-name podinfo-lambda-deploy \
              --deployment-group-name podinfo-lambda-group \
              --deployment-config-name CodeDeployDefault.LambdaCanary10Percent5Minutes \
              --description "Deploy ${{ github.sha }} to Lambda"
          else
            echo "CodeDeploy is not available in this AWS CLI installation, skipping..."
          fi
      
      - name: Deploy EC2 application
        run: |
          # Get the latest Auto Scaling Group instances
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --query 'AutoScalingGroups[?contains(AutoScalingGroupName, `podinfo`)].AutoScalingGroupName' --output text)
          
          # Create user data script
          cat > user_data.sh << 'EOF'
          #!/bin/bash
          # Update system
          yum update -y
          
          # Install Docker
          yum install -y docker
          systemctl start docker
          systemctl enable docker
          
          # Install CloudWatch agent
          yum install -y amazon-cloudwatch-agent
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          # Pull and run the new image
          docker pull ${{ secrets.ECR_REPOSITORY_EC2 }}:${{ steps.get-digests.outputs.ec2_digest }}
          docker stop podinfo || true
          docker rm podinfo || true
          docker run -d --name podinfo -p 8080:8080 ${{ secrets.ECR_REPOSITORY_EC2 }}:${{ steps.get-digests.outputs.ec2_digest }}
          
          # Start CloudWatch agent
          /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c ssm:AmazonCloudWatch-linux -s
          EOF
          
          # Encode user data to base64
          USER_DATA_B64=$(base64 -w 0 user_data.sh)
          
          # Create a new Launch Template with updated user data
          NEW_LAUNCH_TEMPLATE_ID=$(aws ec2 create-launch-template \
            --launch-template-name podinfo-github-actions-$(date +%s) \
            --launch-template-data "UserData=$USER_DATA_B64,ImageId=ami-0e6af742d565ff61c,InstanceType=t3.micro,SecurityGroupIds=sg-0c0ae6c0c58040f61" \
            --query 'LaunchTemplate.LaunchTemplateId' --output text)
          
          # Update Auto Scaling Group to use new Launch Template
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name $ASG_NAME \
            --launch-template LaunchTemplateId=$NEW_LAUNCH_TEMPLATE_ID,Version='$Latest'
      
      - name: Deploy EC2 with CodeDeploy
        if: env.ENABLE_CODEDEPLOY == 'true'
        run: |
          # Check if CodeDeploy is available
          if aws codedeploy help > /dev/null 2>&1; then
            aws codedeploy create-deployment \
              --application-name podinfo-ec2-deploy \
              --deployment-group-name podinfo-ec2-group \
              --deployment-config-name CodeDeployDefault.AllAtOnce \
              --description "Deploy ${{ github.sha }} to EC2"
          else
            echo "CodeDeploy is not available in this AWS CLI installation, skipping..."
          fi
      
      - name: Wait for deployments
        run: |
          echo "Waiting for deployments to complete..."
          sleep 300
      
      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."
          
          # Test Lambda endpoint (if API Gateway exists)
          LAMBDA_URL=$(aws apigatewayv2 get-apis --query 'Items[?contains(Name, `podinfo`)].ApiEndpoint | [0]' --output text 2>/dev/null || echo "")
          if [ -n "$LAMBDA_URL" ] && [ "$LAMBDA_URL" != "None" ]; then
            echo "Testing Lambda endpoint: $LAMBDA_URL/healthz"
            if curl -f -m 10 "$LAMBDA_URL/healthz"; then
              echo "✅ Lambda health check passed"
            else
              echo "⚠️  Lambda health check failed, but continuing..."
            fi
          else
            echo "⚠️  API Gateway not found, skipping Lambda endpoint test"
          fi
          
          # Test ALB endpoint (if ALB exists)
          ALB_DNS=$(aws elbv2 describe-load-balancers --query 'LoadBalancers[?contains(LoadBalancerName, `podinfo`)].DNSName | [0]' --output text 2>/dev/null || echo "")
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            echo "Testing ALB endpoint: http://$ALB_DNS/healthz"
            if curl -f -m 10 "http://$ALB_DNS/healthz"; then
              echo "✅ ALB health check passed"
            else
              echo "⚠️  ALB health check failed, but continuing..."
            fi
          else
            echo "⚠️  ALB not found, skipping ALB endpoint test"
          fi
          
          echo "Smoke tests completed"
      
      - name: Run synthetic tests
        run: |
          # Synthetic test script
          ./scripts/smoke-tests.sh dev
      
      - name: Update deployment status
        run: |
          echo "Deployment to dev environment completed successfully"
          echo "Image digest: ${{ env.IMAGE_TAG }}"

  promote-to-prod:
    name: Promote to Production
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    if: github.event.workflow_run.conclusion == 'success' && github.ref == 'refs/heads/main'
    environment: production
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Verify image signature
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.2.0'
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Get image digests
        id: get-digests
        run: |
          # Get the actual image digests (not just the tag)
          # The build workflow tags images with commit SHA, we need the actual digest
          IMAGE_TAG="${{ github.event.workflow_run.head_sha }}"
          
          # Get EC2 image digest
          EC2_DIGEST=$(aws ecr describe-images \
            --repository-name podinfo-podinfo \
            --image-ids imageTag=$IMAGE_TAG \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          echo "ec2_digest=$EC2_DIGEST" >> $GITHUB_OUTPUT
          echo "EC2 Image Digest: $EC2_DIGEST"
          
          # Get Lambda image digest
          LAMBDA_DIGEST=$(aws ecr describe-images \
            --repository-name podinfo-podinfo-lambda \
            --image-ids imageTag=$IMAGE_TAG \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          echo "lambda_digest=$LAMBDA_DIGEST" >> $GITHUB_OUTPUT
          echo "Lambda Image Digest: $LAMBDA_DIGEST"
      
      - name: Verify Podinfo image signature
        run: |
          cosign verify \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.+" \
            ${{ secrets.ECR_REPOSITORY_EC2 }}@${{ steps.get-digests.outputs.ec2_digest }}
      
      - name: Verify Lambda image signature
        run: |
          cosign verify \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.+" \
            ${{ secrets.ECR_REPOSITORY_LAMBDA }}@${{ steps.get-digests.outputs.lambda_digest }}
      
      - name: Deploy Lambda function
        run: |
          IMAGE_TAG="${{ github.event.workflow_run.head_sha }}"
          echo "Deploying Lambda function to PRODUCTION with image: ${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG"
          
          # Check if Lambda function exists
          if aws lambda get-function --function-name podinfo-lambda >/dev/null 2>&1; then
            echo "Lambda function exists, updating with container image..."
            aws lambda update-function-code \
              --function-name podinfo-lambda \
              --image-uri ${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG
            # Wait for update to complete
            echo "Waiting for Lambda function update to complete..."
            aws lambda wait function-updated --function-name podinfo-lambda
          else
            echo "Lambda function does not exist, creating with container image..."
            aws lambda create-function \
              --function-name podinfo-lambda \
              --package-type Image \
              --code ImageUri=${{ secrets.ECR_REPOSITORY_LAMBDA }}:$IMAGE_TAG \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/podinfo-lambda-execution-role \
              --timeout 30 \
              --memory-size 512 \
              --environment Variables='{ENVIRONMENT=prod,LOG_LEVEL=INFO}'
            # Wait for function to be ready
            echo "Waiting for Lambda function to be ready..."
            aws lambda wait function-active --function-name podinfo-lambda
          fi
        
          aws lambda publish-version \
            --function-name podinfo-lambda \
            --description "Production deployment $IMAGE_TAG"
      
      - name: Deploy Lambda with CodeDeploy
        if: env.ENABLE_CODEDEPLOY == 'true'
        run: |
          # Check if CodeDeploy is available
          if aws codedeploy help > /dev/null 2>&1; then
            aws codedeploy create-deployment \
              --application-name podinfo-lambda-deploy \
              --deployment-group-name podinfo-lambda-group \
              --deployment-config-name CodeDeployDefault.LambdaCanary10Percent5Minutes \
              --description "Production deploy ${{ github.sha }} to Lambda"
          else
            echo "CodeDeploy is not available in this AWS CLI installation, skipping..."
          fi
      
      - name: Deploy EC2 application
        run: |
          # Get the latest Auto Scaling Group instances
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --query 'AutoScalingGroups[?contains(AutoScalingGroupName, `podinfo`)].AutoScalingGroupName' --output text)
          
          # Create user data script
          cat > user_data.sh << 'EOF'
          #!/bin/bash
          # Update system
          yum update -y
          
          # Install Docker
          yum install -y docker
          systemctl start docker
          systemctl enable docker
          
          # Install CloudWatch agent
          yum install -y amazon-cloudwatch-agent
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          # Pull and run the new image
          docker pull ${{ secrets.ECR_REPOSITORY_EC2 }}:${{ steps.get-digests.outputs.ec2_digest }}
          docker stop podinfo || true
          docker rm podinfo || true
          docker run -d --name podinfo -p 8080:8080 ${{ secrets.ECR_REPOSITORY_EC2 }}:${{ steps.get-digests.outputs.ec2_digest }}
          
          # Start CloudWatch agent
          /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c ssm:AmazonCloudWatch-linux -s
          EOF
          
          # Encode user data to base64
          USER_DATA_B64=$(base64 -w 0 user_data.sh)
          
          # Create a new Launch Template with updated user data
          NEW_LAUNCH_TEMPLATE_ID=$(aws ec2 create-launch-template \
            --launch-template-name podinfo-github-actions-$(date +%s) \
            --launch-template-data "UserData=$USER_DATA_B64,ImageId=ami-0e6af742d565ff61c,InstanceType=t3.micro,SecurityGroupIds=sg-0c0ae6c0c58040f61" \
            --query 'LaunchTemplate.LaunchTemplateId' --output text)
          
          # Update Auto Scaling Group to use new Launch Template
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name $ASG_NAME \
            --launch-template LaunchTemplateId=$NEW_LAUNCH_TEMPLATE_ID,Version='$Latest'
      
      - name: Deploy EC2 with CodeDeploy
        if: env.ENABLE_CODEDEPLOY == 'true'
        run: |
          # Check if CodeDeploy is available
          if aws codedeploy help > /dev/null 2>&1; then
            aws codedeploy create-deployment \
              --application-name podinfo-ec2-deploy \
              --deployment-group-name podinfo-ec2-group \
              --deployment-config-name CodeDeployDefault.AllAtOnce \
              --description "Production deploy ${{ github.sha }} to EC2"
          else
            echo "CodeDeploy is not available in this AWS CLI installation, skipping..."
          fi
      
      - name: Wait for deployments
        run: |
          echo "Waiting for production deployments to complete..."
          sleep 300
      
      - name: Run production smoke tests
        run: |
          # Test Lambda endpoint
          LAMBDA_URL=$(aws apigatewayv2 get-apis --query 'Items[?Name==`podinfo-api`].ApiEndpoint' --output text)
          curl -f $LAMBDA_URL/healthz || exit 1
          
          # Test ALB endpoint
          ALB_DNS=$(aws elbv2 describe-load-balancers --names podinfo-alb --query 'LoadBalancers[0].DNSName' --output text)
          curl -f http://$ALB_DNS/healthz || exit 1
      
      - name: Run production synthetic tests
        run: |
          ./scripts/smoke-tests.sh prod
      
      - name: Update production status
        run: |
          echo "Production deployment completed successfully"
          echo "Image digest: ${{ env.IMAGE_TAG }}"
          echo "Deployment timestamp: $(date -u)"
